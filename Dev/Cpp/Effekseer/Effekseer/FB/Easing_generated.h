// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EASING_EFFEKSEER_FB_H_
#define FLATBUFFERS_GENERATED_EASING_EFFEKSEER_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "CommonStructures_generated.h"

namespace Effekseer {
namespace FB {

struct FloatEasing;
struct FloatEasingBuilder;

struct Vec3FEasing;
struct Vec3FEasingBuilder;

enum class Easing3Type : int32_t {
  StartEndSpeed = 0,
  Linear = 1,
  EaseInQuadratic = 10,
  EaseOutQuadratic = 11,
  EaseInOutQuadratic = 12,
  EaseInCubic = 20,
  EaseOutCubic = 21,
  EaseInOutCubic = 22,
  EaseInQuartic = 30,
  EaseOutQuartic = 31,
  EaseInOutQuartic = 32,
  EaseInQuintic = 40,
  EaseOutQuintic = 41,
  EaseInOutQuintic = 42,
  EaseInBack = 50,
  EaseOutBack = 51,
  EaseInOutBack = 52,
  EaseInBounce = 60,
  EaseOutBounce = 61,
  EaseInOutBounce = 62,
  MIN = StartEndSpeed,
  MAX = EaseInOutBounce
};

inline const Easing3Type (&EnumValuesEasing3Type())[20] {
  static const Easing3Type values[] = {
    Easing3Type::StartEndSpeed,
    Easing3Type::Linear,
    Easing3Type::EaseInQuadratic,
    Easing3Type::EaseOutQuadratic,
    Easing3Type::EaseInOutQuadratic,
    Easing3Type::EaseInCubic,
    Easing3Type::EaseOutCubic,
    Easing3Type::EaseInOutCubic,
    Easing3Type::EaseInQuartic,
    Easing3Type::EaseOutQuartic,
    Easing3Type::EaseInOutQuartic,
    Easing3Type::EaseInQuintic,
    Easing3Type::EaseOutQuintic,
    Easing3Type::EaseInOutQuintic,
    Easing3Type::EaseInBack,
    Easing3Type::EaseOutBack,
    Easing3Type::EaseInOutBack,
    Easing3Type::EaseInBounce,
    Easing3Type::EaseOutBounce,
    Easing3Type::EaseInOutBounce
  };
  return values;
}

inline const char * const *EnumNamesEasing3Type() {
  static const char * const names[64] = {
    "StartEndSpeed",
    "Linear",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInQuadratic",
    "EaseOutQuadratic",
    "EaseInOutQuadratic",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInCubic",
    "EaseOutCubic",
    "EaseInOutCubic",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInQuartic",
    "EaseOutQuartic",
    "EaseInOutQuartic",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInQuintic",
    "EaseOutQuintic",
    "EaseInOutQuintic",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInBack",
    "EaseOutBack",
    "EaseInOutBack",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "EaseInBounce",
    "EaseOutBounce",
    "EaseInOutBounce",
    nullptr
  };
  return names;
}

inline const char *EnumNameEasing3Type(Easing3Type e) {
  if (flatbuffers::IsOutRange(e, Easing3Type::StartEndSpeed, Easing3Type::EaseInOutBounce)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEasing3Type()[index];
}

struct FloatEasing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatEasingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_MIDDLE = 8,
    VT_TYPE = 10,
    VT_PARAMS = 12,
    VT_CHANNEL = 14,
    VT_IS_MIDDLE_ENABLED = 16,
    VT_IS_INDIVIDUAL_ENABLED = 18,
    VT_TYPES = 20
  };
  const Effekseer::FB::FloatRange *start() const {
    return GetStruct<const Effekseer::FB::FloatRange *>(VT_START);
  }
  const Effekseer::FB::FloatRange *end() const {
    return GetStruct<const Effekseer::FB::FloatRange *>(VT_END);
  }
  const Effekseer::FB::FloatRange *middle() const {
    return GetStruct<const Effekseer::FB::FloatRange *>(VT_MIDDLE);
  }
  Effekseer::FB::Easing3Type type() const {
    return static_cast<Effekseer::FB::Easing3Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *params() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PARAMS);
  }
  int32_t channel() const {
    return GetField<int32_t>(VT_CHANNEL, 0);
  }
  bool is_middle_enabled() const {
    return GetField<uint8_t>(VT_IS_MIDDLE_ENABLED, 0) != 0;
  }
  bool is_individual_enabled() const {
    return GetField<uint8_t>(VT_IS_INDIVIDUAL_ENABLED, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *types() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Effekseer::FB::FloatRange>(verifier, VT_START) &&
           VerifyField<Effekseer::FB::FloatRange>(verifier, VT_END) &&
           VerifyField<Effekseer::FB::FloatRange>(verifier, VT_MIDDLE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           VerifyField<int32_t>(verifier, VT_CHANNEL) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIDDLE_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_INDIVIDUAL_ENABLED) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           verifier.EndTable();
  }
};

struct FloatEasingBuilder {
  typedef FloatEasing Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(const Effekseer::FB::FloatRange *start) {
    fbb_.AddStruct(FloatEasing::VT_START, start);
  }
  void add_end(const Effekseer::FB::FloatRange *end) {
    fbb_.AddStruct(FloatEasing::VT_END, end);
  }
  void add_middle(const Effekseer::FB::FloatRange *middle) {
    fbb_.AddStruct(FloatEasing::VT_MIDDLE, middle);
  }
  void add_type(Effekseer::FB::Easing3Type type) {
    fbb_.AddElement<int32_t>(FloatEasing::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<float>> params) {
    fbb_.AddOffset(FloatEasing::VT_PARAMS, params);
  }
  void add_channel(int32_t channel) {
    fbb_.AddElement<int32_t>(FloatEasing::VT_CHANNEL, channel, 0);
  }
  void add_is_middle_enabled(bool is_middle_enabled) {
    fbb_.AddElement<uint8_t>(FloatEasing::VT_IS_MIDDLE_ENABLED, static_cast<uint8_t>(is_middle_enabled), 0);
  }
  void add_is_individual_enabled(bool is_individual_enabled) {
    fbb_.AddElement<uint8_t>(FloatEasing::VT_IS_INDIVIDUAL_ENABLED, static_cast<uint8_t>(is_individual_enabled), 0);
  }
  void add_types(flatbuffers::Offset<flatbuffers::Vector<int32_t>> types) {
    fbb_.AddOffset(FloatEasing::VT_TYPES, types);
  }
  explicit FloatEasingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloatEasing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatEasing>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatEasing> CreateFloatEasing(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Effekseer::FB::FloatRange *start = 0,
    const Effekseer::FB::FloatRange *end = 0,
    const Effekseer::FB::FloatRange *middle = 0,
    Effekseer::FB::Easing3Type type = Effekseer::FB::Easing3Type::StartEndSpeed,
    flatbuffers::Offset<flatbuffers::Vector<float>> params = 0,
    int32_t channel = 0,
    bool is_middle_enabled = false,
    bool is_individual_enabled = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> types = 0) {
  FloatEasingBuilder builder_(_fbb);
  builder_.add_types(types);
  builder_.add_channel(channel);
  builder_.add_params(params);
  builder_.add_type(type);
  builder_.add_middle(middle);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_is_individual_enabled(is_individual_enabled);
  builder_.add_is_middle_enabled(is_middle_enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatEasing> CreateFloatEasingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Effekseer::FB::FloatRange *start = 0,
    const Effekseer::FB::FloatRange *end = 0,
    const Effekseer::FB::FloatRange *middle = 0,
    Effekseer::FB::Easing3Type type = Effekseer::FB::Easing3Type::StartEndSpeed,
    const std::vector<float> *params = nullptr,
    int32_t channel = 0,
    bool is_middle_enabled = false,
    bool is_individual_enabled = false,
    const std::vector<int32_t> *types = nullptr) {
  auto params__ = params ? _fbb.CreateVector<float>(*params) : 0;
  auto types__ = types ? _fbb.CreateVector<int32_t>(*types) : 0;
  return Effekseer::FB::CreateFloatEasing(
      _fbb,
      start,
      end,
      middle,
      type,
      params__,
      channel,
      is_middle_enabled,
      is_individual_enabled,
      types__);
}

struct Vec3FEasing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vec3FEasingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_MIDDLE = 8,
    VT_TYPE = 10,
    VT_PARAMS = 12,
    VT_CHANNEL = 14,
    VT_IS_MIDDLE_ENABLED = 16,
    VT_IS_INDIVIDUAL_ENABLED = 18,
    VT_TYPES = 20
  };
  const Effekseer::FB::Vec3FRange *start() const {
    return GetStruct<const Effekseer::FB::Vec3FRange *>(VT_START);
  }
  const Effekseer::FB::Vec3FRange *end() const {
    return GetStruct<const Effekseer::FB::Vec3FRange *>(VT_END);
  }
  const Effekseer::FB::Vec3FRange *middle() const {
    return GetStruct<const Effekseer::FB::Vec3FRange *>(VT_MIDDLE);
  }
  Effekseer::FB::Easing3Type type() const {
    return static_cast<Effekseer::FB::Easing3Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *params() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_PARAMS);
  }
  int32_t channel() const {
    return GetField<int32_t>(VT_CHANNEL, 0);
  }
  bool is_middle_enabled() const {
    return GetField<uint8_t>(VT_IS_MIDDLE_ENABLED, 0) != 0;
  }
  bool is_individual_enabled() const {
    return GetField<uint8_t>(VT_IS_INDIVIDUAL_ENABLED, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *types() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Effekseer::FB::Vec3FRange>(verifier, VT_START) &&
           VerifyField<Effekseer::FB::Vec3FRange>(verifier, VT_END) &&
           VerifyField<Effekseer::FB::Vec3FRange>(verifier, VT_MIDDLE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           VerifyField<int32_t>(verifier, VT_CHANNEL) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIDDLE_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_INDIVIDUAL_ENABLED) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           verifier.EndTable();
  }
};

struct Vec3FEasingBuilder {
  typedef Vec3FEasing Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(const Effekseer::FB::Vec3FRange *start) {
    fbb_.AddStruct(Vec3FEasing::VT_START, start);
  }
  void add_end(const Effekseer::FB::Vec3FRange *end) {
    fbb_.AddStruct(Vec3FEasing::VT_END, end);
  }
  void add_middle(const Effekseer::FB::Vec3FRange *middle) {
    fbb_.AddStruct(Vec3FEasing::VT_MIDDLE, middle);
  }
  void add_type(Effekseer::FB::Easing3Type type) {
    fbb_.AddElement<int32_t>(Vec3FEasing::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<float>> params) {
    fbb_.AddOffset(Vec3FEasing::VT_PARAMS, params);
  }
  void add_channel(int32_t channel) {
    fbb_.AddElement<int32_t>(Vec3FEasing::VT_CHANNEL, channel, 0);
  }
  void add_is_middle_enabled(bool is_middle_enabled) {
    fbb_.AddElement<uint8_t>(Vec3FEasing::VT_IS_MIDDLE_ENABLED, static_cast<uint8_t>(is_middle_enabled), 0);
  }
  void add_is_individual_enabled(bool is_individual_enabled) {
    fbb_.AddElement<uint8_t>(Vec3FEasing::VT_IS_INDIVIDUAL_ENABLED, static_cast<uint8_t>(is_individual_enabled), 0);
  }
  void add_types(flatbuffers::Offset<flatbuffers::Vector<int32_t>> types) {
    fbb_.AddOffset(Vec3FEasing::VT_TYPES, types);
  }
  explicit Vec3FEasingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vec3FEasing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec3FEasing>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec3FEasing> CreateVec3FEasing(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Effekseer::FB::Vec3FRange *start = 0,
    const Effekseer::FB::Vec3FRange *end = 0,
    const Effekseer::FB::Vec3FRange *middle = 0,
    Effekseer::FB::Easing3Type type = Effekseer::FB::Easing3Type::StartEndSpeed,
    flatbuffers::Offset<flatbuffers::Vector<float>> params = 0,
    int32_t channel = 0,
    bool is_middle_enabled = false,
    bool is_individual_enabled = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> types = 0) {
  Vec3FEasingBuilder builder_(_fbb);
  builder_.add_types(types);
  builder_.add_channel(channel);
  builder_.add_params(params);
  builder_.add_type(type);
  builder_.add_middle(middle);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_is_individual_enabled(is_individual_enabled);
  builder_.add_is_middle_enabled(is_middle_enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vec3FEasing> CreateVec3FEasingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Effekseer::FB::Vec3FRange *start = 0,
    const Effekseer::FB::Vec3FRange *end = 0,
    const Effekseer::FB::Vec3FRange *middle = 0,
    Effekseer::FB::Easing3Type type = Effekseer::FB::Easing3Type::StartEndSpeed,
    const std::vector<float> *params = nullptr,
    int32_t channel = 0,
    bool is_middle_enabled = false,
    bool is_individual_enabled = false,
    const std::vector<int32_t> *types = nullptr) {
  auto params__ = params ? _fbb.CreateVector<float>(*params) : 0;
  auto types__ = types ? _fbb.CreateVector<int32_t>(*types) : 0;
  return Effekseer::FB::CreateVec3FEasing(
      _fbb,
      start,
      end,
      middle,
      type,
      params__,
      channel,
      is_middle_enabled,
      is_individual_enabled,
      types__);
}

}  // namespace FB
}  // namespace Effekseer

#endif  // FLATBUFFERS_GENERATED_EASING_EFFEKSEER_FB_H_
