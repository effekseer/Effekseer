// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EFFECTSTRUCTURES_EFFEKSEER_FB_EFFECT_H_
#define FLATBUFFERS_GENERATED_EFFECTSTRUCTURES_EFFEKSEER_FB_EFFECT_H_

#include "flatbuffers/flatbuffers.h"

#include "CommonStructures_generated.h"

namespace Effekseer {
namespace FB {
namespace Effect {

struct TextureProperty;
struct TexturePropertyBuilder;

enum class EffectNodeType : int32_t {
  EffectNodeType_Root = -1,
  EffectNodeType_NoneType = 0,
  EffectNodeType_Sprite = 2,
  EffectNodeType_Ribbon = 3,
  EffectNodeType_Ring = 4,
  EffectNodeType_Model = 5,
  EffectNodeType_Track = 6,
  MIN = EffectNodeType_Root,
  MAX = EffectNodeType_Track
};

inline const EffectNodeType (&EnumValuesEffectNodeType())[7] {
  static const EffectNodeType values[] = {
    EffectNodeType::EffectNodeType_Root,
    EffectNodeType::EffectNodeType_NoneType,
    EffectNodeType::EffectNodeType_Sprite,
    EffectNodeType::EffectNodeType_Ribbon,
    EffectNodeType::EffectNodeType_Ring,
    EffectNodeType::EffectNodeType_Model,
    EffectNodeType::EffectNodeType_Track
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeType() {
  static const char * const names[9] = {
    "EffectNodeType_Root",
    "EffectNodeType_NoneType",
    "",
    "EffectNodeType_Sprite",
    "EffectNodeType_Ribbon",
    "EffectNodeType_Ring",
    "EffectNodeType_Model",
    "EffectNodeType_Track",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeType(EffectNodeType e) {
  if (flatbuffers::IsOutRange(e, EffectNodeType::EffectNodeType_Root, EffectNodeType::EffectNodeType_Track)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EffectNodeType::EffectNodeType_Root);
  return EnumNamesEffectNodeType()[index];
}

enum class TranslationParentBindType : int32_t {
  TranslationParentBindType_NotBind = 0,
  TranslationParentBindType_WhenCreating = 1,
  TranslationParentBindType_Always = 2,
  TranslationParentBindType_NotBind_Root = 3,
  TranslationParentBindType_NotBind_FollowParent = 4,
  TranslationParentBindType_WhenCreating_FollowParent = 5,
  MIN = TranslationParentBindType_NotBind,
  MAX = TranslationParentBindType_WhenCreating_FollowParent
};

inline const TranslationParentBindType (&EnumValuesTranslationParentBindType())[6] {
  static const TranslationParentBindType values[] = {
    TranslationParentBindType::TranslationParentBindType_NotBind,
    TranslationParentBindType::TranslationParentBindType_WhenCreating,
    TranslationParentBindType::TranslationParentBindType_Always,
    TranslationParentBindType::TranslationParentBindType_NotBind_Root,
    TranslationParentBindType::TranslationParentBindType_NotBind_FollowParent,
    TranslationParentBindType::TranslationParentBindType_WhenCreating_FollowParent
  };
  return values;
}

inline const char * const *EnumNamesTranslationParentBindType() {
  static const char * const names[7] = {
    "TranslationParentBindType_NotBind",
    "TranslationParentBindType_WhenCreating",
    "TranslationParentBindType_Always",
    "TranslationParentBindType_NotBind_Root",
    "TranslationParentBindType_NotBind_FollowParent",
    "TranslationParentBindType_WhenCreating_FollowParent",
    nullptr
  };
  return names;
}

inline const char *EnumNameTranslationParentBindType(TranslationParentBindType e) {
  if (flatbuffers::IsOutRange(e, TranslationParentBindType::TranslationParentBindType_NotBind, TranslationParentBindType::TranslationParentBindType_WhenCreating_FollowParent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTranslationParentBindType()[index];
}

enum class BindType : int32_t {
  BindType_NotBind = 0,
  BindType_WhenCreating = 1,
  BindType_Always = 2,
  BindType_NotBind_Root = 3,
  MIN = BindType_NotBind,
  MAX = BindType_NotBind_Root
};

inline const BindType (&EnumValuesBindType())[4] {
  static const BindType values[] = {
    BindType::BindType_NotBind,
    BindType::BindType_WhenCreating,
    BindType::BindType_Always,
    BindType::BindType_NotBind_Root
  };
  return values;
}

inline const char * const *EnumNamesBindType() {
  static const char * const names[5] = {
    "BindType_NotBind",
    "BindType_WhenCreating",
    "BindType_Always",
    "BindType_NotBind_Root",
    nullptr
  };
  return names;
}

inline const char *EnumNameBindType(BindType e) {
  if (flatbuffers::IsOutRange(e, BindType::BindType_NotBind, BindType::BindType_NotBind_Root)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBindType()[index];
}

struct TextureProperty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TexturePropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct TexturePropertyBuilder {
  typedef TextureProperty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(TextureProperty::VT_PATH, path);
  }
  explicit TexturePropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureProperty>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureProperty> CreateTextureProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  TexturePropertyBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureProperty> CreateTexturePropertyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return Effekseer::FB::Effect::CreateTextureProperty(
      _fbb,
      path__);
}

}  // namespace Effect
}  // namespace FB
}  // namespace Effekseer

#endif  // FLATBUFFERS_GENERATED_EFFECTSTRUCTURES_EFFEKSEER_FB_EFFECT_H_
